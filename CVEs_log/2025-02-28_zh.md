总结果：271，高严重性：40，时间戳：2025-02-28 08:10:07
开始日期：现在；结束日期：2025-02-27

| 编号 | CVE ID | 基础分数 | 严重性 | 描述 | 参考资料 |
|-----|--------|------------|----------|-------------|------------|
| 1 | CVE-2024-57979 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：pps：修复使用后释放错误在运行ntpd和gpsd的板上，我在重新启动时从gpsd的sys_exit()中看到一个持续的使用后释放错误：<br><br>    pps pps1: 已移除<br>    ------------[在此截断]------------<br>    kobject: `(null)` (00000000db4bec24)：尚未初始化，但正在调用kobject_put()。<br>    警告：CPU: 2 PID: 440 在 lib/kobject.c:734 kobject_put+0x120/0x150 处<br>    CPU: 2 UID: 299 PID: 440 Comm: gpsd 不纯净 6.11.0-rc6-00308-gb31c44928842 #1<br>    硬件名称：Raspberry Pi 4 Model B Rev 1.1（DT）<br>    pstate: 60000005 (nZCv daif -PAN -UAO -TCO -DIT -SSBS BTYPE=--)<br>    pc : kobject_put+0x120/0x150<br>    lr : kobject_put+0x120/0x150<br>    sp : ffffffc0803d3ae0<br>    x29: ffffffc0803d3ae0 x28: ffffff8042dc9738 x27: 0000000000000001<br>    x26: 0000000000000000 x25: ffffff8042dc9040 x24: ffffff8042dc9440<br>    x23: ffffff80402a4620 x22: ffffff8042ef4bd0 x21: ffffff80405cb600<br>    x20: 000000000008001b x19: ffffff8040b3b6e0 x18: 0000000000000000<br>    x17: 0000000000000000 x16: 0000000000000000 x15: 696e6920746f6e20<br>    x14: 7369203a29343263 x13: 205d303434542020 x12: 0000000000000000<br>    x11: 0000000000000000 x10: 0000000000000000 x9 : 0000000000000000<br>    x8 : 0000000000000000 x7 : 0000000000000000 x6 : 0000000000000000<br>    x5 : 0000000000000000 x4 : 0000000000000000 x3 : 0000000000000000<br>    x2 : 0000000000000000 x1 : 0000000000000000 x0 : 0000000000000000<br><br>    调用跟踪：<br>    kobject_put+0x120/0x150<br>    cdev_put+0x20/0x3c<br>    __fput+0x2c4/0x2d8<br>    ____fput+0x1c/0x38<br>    task_work_run+0x70/0xfc<br>    do_exit+0x2a0/0x924<br>    do_group_exit+0x34/0x90<br>    get_signal+0x7fc/0x8c0<br>    do_signal+0x128/0x13b4<br>    do_notify_resume+0xdc/0x160<br>    el0_svc+0xd4/0xf8<br>    el0t_64_sync_handler+0x140/0x14c<br>    el0t_64_sync+0x190/0x194<br>    ---[结束跟踪0000000000000000]---<br>    ...随后是更多损坏症状，具有类似的堆栈跟踪：<br>    refcount_t: 溢出；使用后释放。<br>    kernel BUG at lib/list_debug.c:62!<br>    Kernel panic - not syncing: Oops - BUG: 致命异常<br><br>这发生是因为pps_device_destruct()在调用cdev_del()之后立即释放了pps_device及其嵌入的cdev，但如cdev_del()注释所述，先前打开的cdev的操作符在cdev_del()返回后仍然可调用。我认为这个错误一直存在：我无法解释为什么它突然在每次重新启动此特定板时都开始出现。<br><br>在提交d953e0e837e6("pps：在注销源时修复使用后释放错误")中，George Spelvin建议删除嵌入的cdev。这似乎是修复此问题的最简单方法，所以我实现了他的建议，使用__register_chrdev()，pps_idr成为确定哪个次要设备对应于哪个设备的真相来源。<br><br>但现在pps_idr定义了用户空间可见性而不是cdev_add()，我们需要确保pps->dev引用计数不能达到零，同时用户空间仍然可以找到它。因此，idr_remove()调用移动到pps_unregister_cdev()，并且pps_idr现在持有对pps->dev的引用。<br><br>    pps_core: 源serial1获取cdev (251:1)<br>    <...><br>    pps pps1: 已移除<br>    pps_core: 注销pps1<br>    pps_core: 释放pps1 | [1]https://git.kernel.org/stable/c/7e5ee3281dc09014367f5112b6d566ba36ea2d49<br>[2]https://git.kernel.org/stable/c/85241f7de216f8298f6e48540ea13d7dcd100870<br>[3]https://git.kernel.org/stable/c/91932db1d96b2952299ce30c1c693d834d10ace6<br>[4]https://git.kernel.org/stable/c/c79a39dc8d060b9e64e8b0fa9d245d44befeefbe<br>[5]https://git.kernel.org/stable/c/cd3bbcb6b3a7caa5ce67de76723b6d8531fb7f64 |
| 2 | CVE-2024-57984 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：i3c: dw: 由于竞态条件，在dw_i3c_master驱动程序中修复使用后释放问题。在dw_i3c_common_probe中，&master->hj_work与dw_i3c_hj_work绑定。而dw_i3c_master_irq_handler可以调用dw_i3c_master_irq_handle_ibis函数来启动该工作。如果我们卸载模块，这将调用dw_i3c_common_remove进行清理，并通过i3c_master_unregister释放master->base，而上述提到的工作仍会被使用。可能导致UAF（使用后释放）漏洞的操作顺序如下：<br><br>CPU0                                      CPU1 | dw_i3c_hj_workdw_i3c_common_remove                 |i3c_master_unregister(&master->base) |device_unregister(&master->dev)      |device_release                       |//free master->base                  |                                     | i3c_master_do_daa(&master->base)                                     | //use master->baseFix it by ensuring that the work is canceled before proceeding withthe cleanup in dw_i3c_common_remove. | [1]https://git.kernel.org/stable/c/60d2fb033a999bb644f8e8606ff4a1b82de36c6f<br>[2]https://git.kernel.org/stable/c/9b0063098fcde17cd2894f2c96459b23388507ca<br>[3]https://git.kernel.org/stable/c/b75439c945b94dd8a2b645355bdb56f948052601<br>[4]https://git.kernel.org/stable/c/fc84dd3c909a372c0d130f5f84c404717c17eed8 |
| 3 | CVE-2025-21714 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：RDMA/mlx5：修复释放后隐式ODP使用修复通过使用__xa_cmpxchg()来防止隐式ODP mr销毁工作的重复排队，确保我们仅在此时销毁特定的mr。<br><br>如果没有此更改，我们可能会两次尝试使该mr失效，这反过来可能导致两次排队销毁mr的工作，并最终由于第一个工作导致mr被释放后，第二个工作执行，从而造成释放后使用和以下跟踪。  <br>引用计数：下溢；释放后使用。<br>警告：CPU：2 PID：12178 在 lib/refcount.c:28 refcount_warn_saturate+0x12b/0x130<br><br>链接到的模块：bonding ib_ipoib vfio_pci ip_gre geneve nf_tables ip6_gre gre ip6_tunnel tunnel6 ipip tunnel4 ib_umad rdma_ucm mlx5_vfio_pci vfio_pci_core vfio_iommu_type1 mlx5_ib vfio ib_uverbs mlx5_core iptable_raw openvswitch nsh rpcrdma ib_iser libiscsi scsi_transport_iscsi rdma_cm iw_cm ib_cm ib_core xt_conntrack xt_MASQUERADE nf_conntrack_netlink nfnetlink xt_addrtype iptable_nat nf_nat br_netfilter rpcsec_gss_krb5 auth_rpcgss oid_registry overlay zram zsmalloc fuse [最后卸载：ib_uverbs]<br><br>CPU：2 PID：12178 Comm：kworker/u20:5 不包含#1<br>硬件名称：QEMU标准PC（Q35 + ICH9，2009），BIOS版本rel-1.13.0-0-gf21b5a4aeb02-prebuilt.qemu.org 04/01/2014<br><br>工作队列：未绑定事件 free_implicit_child_mr_work [mlx5_ib]<br><br>RIP：0010:refcount_warn_saturate+0x12b/0x130<br><br>代码：48 c7 c7 38 95 2a 82 c6 05 bc c6 fe 00 01 e8 0c 66 aa ff 0f 0b 5b c3 48 c7 c7 e0 94 2a 82 c6 05 a7 c6 fe 00 01 e8 f5 65 aa ff <0f> 0b 5b c3 90 8b 07 3d 00 00 00 c0 74 12 83 f8 01 74 13 8d 50 ff<br><br>RSP：0018:ffff8881008e3e40 标志：00010286<br><br>RAX：0000000000000000 RBX：0000000000000000 RCX：0000000000000027<br><br>RDX：ffff88852c91b5c8 RSI：0000000000000001 RDI：ffff88852c91b5c0<br><br>RBP：ffff8881dacd4e00 R08：00000000ffffffff R09：0000000000000019<br><br>R10：000000000000072e R11：0000000063666572 R12：ffff88812bfd9e00<br><br>R13：ffff8881c792d200 R14：ffff88810011c005 R15：ffff8881002099c0<br><br>FS：0000000000000000(0000) GS：ffff88852c900000(0000) knlGS：0000000000000000<br><br>CS：0010 DS：0000 ES：0000 CR0：0000000080050033<br><br>CR2：00007f5694b5e000 CR3：00000001153f6003 CR4：0000000000370ea0<br><br>DR0：0000000000000000 DR1：0000000000000000 DR2：0000000000000000<br><br>DR3：0000000000000000 DR6：00000000fffe0ff0 DR7：0000000000000400<br><br>调用跟踪：<br><TASK><br>? refcount_warn_saturate+0x12b/0x130<br>free_implicit_child_mr_work+0x180/0x1b0 [mlx5_ib]<br>process_one_work+0x1cc/0x3c0<br>worker_thread+0x218/0x3c0<br>kthread+0xc6/0xf0<br>ret_from_fork+0x1f/0x30<br></TASK> | [1]https://git.kernel.org/stable/c/7cc8f681f6d4ae4478ae0f60485fc768f2b450da<br>[2]https://git.kernel.org/stable/c/d3d930411ce390e532470194296658a960887773<br>[3]https://git.kernel.org/stable/c/edfb65dbb9ffd3102f3ff4dd21316158e56f1976 |
| 4 | CVE-2025-21715 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：net: davicom: 修复dm9000_drv_remove中的使用后释放（UAF）。dm是netdev私有数据，在调用free_netdev()之后不能再使用。在调用free_netdev()之后继续使用dm会导致UAF漏洞。通过将free_netdev()移到函数末尾来修复此问题。这与在提交ad297cd2db89 ("net: qcom/emac: 修复emac_remove中的使用后释放（UAF）") 中修复的问题类似。此漏洞由我们的静态分析工具检测到。 | [1]https://git.kernel.org/stable/c/19e65c45a1507a1a2926649d2db3583ed9d55fd9<br>[2]https://git.kernel.org/stable/c/2013c95df6752d9c88221d0f0f37b6f197969390<br>[3]https://git.kernel.org/stable/c/5a54367a7c2378c65aaa4d3cfd952f26adef7aa7<br>[4]https://git.kernel.org/stable/c/c411f9a5fdc9158e8f7c57eac961d3df3eb4d8ca<br>[5]https://git.kernel.org/stable/c/c94ab07edc2843e2f3d46dbd82e5c681503aaadf |
| 5 | CVE-2025-21722 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：nilfs2：不要强制清除folio，如果缓冲区被引用。<br><br>补丁系列：“nilfs2：保护忙的缓冲头免受强制清除”。<br><br>该系列修复了syzbot报告的文件系统损坏并回退到只读时出现的缓冲头状态不一致问题，以及相关的缓冲头使用后释放问题。<br><br>此补丁（共2个）：<br><br>syzbot报告称，在nilfs2检测到文件系统损坏并回退到只读模式后，可能会发生缓冲区状态的一致性问题。其中一个问题是，当nilfs2调用mark_buffer_dirty()将数据或元数据缓冲区标记为脏时，但它检测到缓冲区不在最新状态：警告：CPU：0 PID：6049 在fs/buffer.c:1177 mark_buffer_dirty+0x2e5/0x520 fs/buffer.c:1177... 调用跟踪：<TASK> nilfs_palloc_commit_alloc_entry+0x4b/0x160 fs/nilfs2/alloc.c:598 nilfs_ifile_create_inode+0x1dd/0x3a0 fs/nilfs2/ifile.c:73 nilfs_new_inode+0x254/0x830 fs/nilfs2/inode.c:344 nilfs_mkdir+0x10d/0x340 fs/nilfs2/namei.c:218 vfs_mkdir+0x2f9/0x4f0 fs/namei.c:4257 do_mkdirat+0x264/0x3a0 fs/namei.c:4280 __do_sys_mkdirat fs/namei.c:4295 [inline] __se_sys_mkdirat fs/namei.c:4293 [inline] __x64_sys_mkdirat+0x87/0xa0 fs/namei.c:4293 do_syscall_x64 arch/x86/entry/common.c:52 [inline] do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83 entry_SYSCALL_64_after_hwframe+0x77/0x7f<br><br>另一个问题是，当nilfs_btree_propagate()将脏状态传播到指向脏缓冲区的b树祖先节点时，它检测到源缓冲区不应是脏的状态，但实际上却是：警告：CPU：0 PID：5245 在fs/nilfs2/btree.c:2089 nilfs_btree_propagate+0xc79/0xdf0 fs/nilfs2/btree.c:2089... 调用跟踪：<TASK> nilfs_bmap_propagate+0x75/0x120 fs/nilfs2/bmap.c:345 nilfs_collect_file_data+0x4d/0xd0 fs/nilfs2/segment.c:587 nilfs_segctor_apply_buffers+0x184/0x340 fs/nilfs2/segment.c:1006 nilfs_segctor_scan_file+0x28c/0xa50 fs/nilfs2/segment.c:1045 nilfs_segctor_collect_blocks fs/nilfs2/segment.c:1216 [inline] nilfs_segctor_collect fs/nilfs2/segment.c:1540 [inline] nilfs_segctor_do_construct+0x1c28/0x6b90 fs/nilfs2/segment.c:2115 nilfs_segctor_construct+0x181/0x6b0 fs/nilfs2/segment.c:2479 nilfs_segctor_thread_construct fs/nilfs2/segment.c:2587 [inline] nilfs_segctor_thread+0x69e/0xe80 fs/nilfs2/segment.c:2701 kthread+0x2f0/0x390 kernel/kthread.c:389 ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147 ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244 </TASK><br><br>这两个问题都是由处理页/folio写请求的回调函数引起的。当它们检测到只读回退时，在意外的时间强制清除各种状态，包括它们持有的缓冲区的工作状态。<br><br>通过在清除页/folio状态之前检查缓冲区是否被引用，并在被引用时跳过清除，来修复这些问题。 | [1]https://git.kernel.org/stable/c/1098bb8d52419d262a3358d099a1598a920b730f<br>[2]https://git.kernel.org/stable/c/19296737024cd220a1d6590bf4c092bca8c99497<br>[3]https://git.kernel.org/stable/c/557ccf5e49f1fb848a29698585bcab2e50a597ef<br>[4]https://git.kernel.org/stable/c/ca76bb226bf47ff04c782cacbd299f12ddee1ec1 |
| 6 | CVE-2025-21726 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：padata：避免reorder_work的使用后释放（UAF）虽然之前的补丁可以避免_do_serial中的ps和ps的UAF，但它不能避免reorder_work的潜在UAF问题。此问题可能如下所示发生：<br><br><br>crypto_request                     crypto_request                    crypto_del_alg<br>padata_do_serial  ...  padata_reorder    // 处理所有剩余的请求然后退出<br>while (1) {<br>    if (!padata)<br>        break;<br>    ...<br>}<br>padata_do_serial                  // 添加新的请求<br>list_add                          // 看到新的请求<br>queue_work(reorder_work)          // 将reorder_work加入工作队列<br>padata_reorder                    // 将reorder_work按squeue->work分配<br>...<br><kworker上下文><br>padata_serial_worker              // 完成新请求，没有更多的待处理请求<br>crypto_del_alg                    // 释放pd<br><kworker上下文><br>invoke_padata_reorder             // pd的UAF<br><br><br>为了避免对`reorder_work`的UAF，在将`reorder_work`放入`serial_wq`之前获取`pd`引用，并且在`serial_wq`完成之前不要释放`pd`引用。 | [1]https://git.kernel.org/stable/c/6f45ef616775b0ce7889b0f6077fc8d681ab30bc<br>[2]https://git.kernel.org/stable/c/7000507bb0d2ceb545c0a690e0c707c897d102c2<br>[3]https://git.kernel.org/stable/c/8ca38d0ca8c3d30dd18d311f1a7ec5cb56972cac<br>[4]https://git.kernel.org/stable/c/a54091c24220a4cd847d5b4f36d678edacddbaf0<br>[5]https://git.kernel.org/stable/c/dd7d37ccf6b11f3d95e797ebe4e9e886d0332600 |
| 7 | CVE-2025-21727 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：padata: 修复padata_reorder中的使用后释放漏洞。当运行LTP测试时发现了该错误：BUG: KASAN: 在padata_find_next + 0x29/0x1a0处的slab使用后释放错误。在地址ffff88bbfe003524处读取大小为4的数据，由任务kworker/u113:2/3039206触发。CPU: 0 PID: 3039206 Comm: kworker/u113:2 Kdump: 已加载 不是最新版本 6.6.0+工作队列: pdecrypt_parallel padata_parallel_worker调用跟踪:<TASK>dump_stack_lvl + 0x32/0x50print_address_description.constprop.0 + 0x6b/0x3d0print_report + 0xdd/0x2c0kasan_report + 0xa5/0xd0padata_find_next + 0x29/0x1a0padata_reorder + 0x131/0x220padata_parallel_worker + 0x3d/0xc0process_one_work + 0x2ec/0x5a0如果在`padata_reorder`函数中调用`padata_find_next`之前添加`mdelay(10)`，则可以很容易地通过LTP测试（pcrypt_aead01）重现此问题。解释如下：pcrypt_aead_encrypt...padata_do_parallelrefcount_inc(&pd->refcnt); // 增加引用计数...padata_do_serialpadata_reorder // pdwhile (1) {padata_find_next(pd, true); // 使用pdqueue_work_on...padata_serial_workercrypto_del_algpadata_put_pd_cnt // 减少引用计数padata_free_shellpadata_put_pd(ps->pd); // pd被释放// 循环再次执行，但pd已被释放// 调用padata_find_next，导致使用后释放错误在padata_reorder函数中，当它在`while`循环中执行时，如果算法被删除，则在进入`padata_find_next`之前引用计数可能会减少到0，从而导致使用后释放错误。如[1]中所述，do_serial应在BH禁用时调用，并始终在RCU保护下进行。为了解决这个问题，在`padata_free_shell`中添加`synchronize_rcu()`以等待所有_do_serial调用完成。[1] https://lore.kernel.org/all/20221028160401.cccypv4euxikusiq@parnassus.localdomain/[2] https://lore.kernel.org/linux-kernel/jfjz5d7zwbytztackem7ibzalm5lnxldi2eofeiczqmqs2m7o6@fq426cwnjtkm/ | [1]https://git.kernel.org/stable/c/0ae2f332cfd2d74cf3ce344ec9938cf3e29c3ccd<br>[2]https://git.kernel.org/stable/c/573ac9c70bf7885dc85d82fa44550581bfc3b738<br>[3]https://git.kernel.org/stable/c/80231f069240d52e98b6a317456c67b2eafd0781<br>[4]https://git.kernel.org/stable/c/bbccae982e9fa1d7abcb23a5ec81cb0ec883f7de<br>[5]https://git.kernel.org/stable/c/e01780ea4661172734118d2a5f41bc9720765668 |
| 8 | CVE-2025-21729 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：wifi: rtw89: 解决cancel_hw_scan和hw_scan完成之间的竞态条件问题。rtwdev->scanning标志原本没有被互斥锁保护，因此cancel_hw_scan可以通过条件检查，但突然hw_scan完成会清除该标志，并调用ieee80211_scan_completed()，这将释放local->hw_scan_req。随后，cancel_hw_scan会产生空指针解引用和使用后释放的错误。通过将检查条件移到受互斥锁保护的位置来修复这个问题。KASAN: 在范围[0x0000000000000088-0x000000000000008f]内检测到空指针解引用。CPU: 2 PID: 6922 进程: kworker/2:2 内核版本: G Tainted OE 硬件名称: LENOVO 2356AD1/2356AD1，BIOS版本: G7ETB6WW (2.76 ) 2019年9月10日 工作队列: events cfg80211_conn_work [cfg80211] RIP: 0010:rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core] 指令: 00 45 89 6c 24 1c 0f 85 23 01 00 00 48 8b 85 20 ff ff ff 48 8d RSP: 0018:ffff88811fd9f068 EFLAGS: 00010206 RAX: dffffc0000000000 RBX: ffff88811fd9f258 RCX: 0000000000000001 RDX: 0000000000000011 RSI: 0000000000000001 RDI: 0000000000000089 RBP: ffff88811fd9f170 R08: 0000000000000000 R09: 0000000000000000 R10: ffff88811fd9f108 R11: 0000000000000000 R12: ffff88810e47f960 R13: 0000000000000000 R14: 000000000000ffff R15: 0000000000000000 FS:  0000000000000000(0000) GS:ffff8881d6f00000(0000) 内核GS:0000000000000000 CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033 CR2: 00007531dfca55b0 CR3: 00000001be296004 CR4: 00000000001706e0 调用跟踪:  <TASK>  ? show_regs+0x61/0x73  ? __die_body+0x20/0x73  ? die_addr+0x4f/0x7b  ? exc_general_protection+0x191/0x1db  ? asm_exc_general_protection+0x27/0x30  ? rtw89_fw_h2c_scan_offload_be+0xc33/0x13c3 [rtw89_core]  ? rtw89_fw_h2c_scan_offload_be+0x458/0x13c3 [rtw89_core]  ? __pfx_rtw89_fw_h2c_scan_offload_be+0x10/0x10 [rtw89_core]  ? do_raw_spin_lock+0x75/0xdb  ? __pfx_do_raw_spin_lock+0x10/0x10  rtw89_hw_scan_offload+0xb5e/0xbf7 [rtw89_core]  ? _raw_spin_unlock+0xe/0x24  ? __mutex_lock.constprop.0+0x40c/0x471  ? __pfx_rtw89_hw_scan_offload+0x10/0x10 [rtw89_core]  ? __mutex_lock_slowpath+0x13/0x1f  ? mutex_lock+0xa2/0xdc  ? __pfx_mutex_lock+0x10/0x10  rtw89_hw_scan_abort+0x58/0xb7 [rtw89_core]  rtw89_ops_cancel_hw_scan+0x120/0x13b [rtw89_core]  ieee80211_scan_cancel+0x468/0x4d0 [mac80211]  ieee80211_prep_connection+0x858/0x899 [mac80211]  ieee80211_mgd_auth+0xbea/0xdde [mac80211]  ? __pfx_ieee80211_mgd_auth+0x10/0x10 [mac80211]  ? cfg80211_find_elem+0x15/0x29 [cfg80211]  ? is_bss+0x1b7/0x1d7 [cfg80211]  ieee80211_auth+0x18/0x27 [mac80211]  cfg80211_mlme_auth+0x3bb/0x3e7 [cfg80211]  cfg80211_conn_do_work+0x410/0xb81 [cfg80211]  ? __pfx_cfg80211_conn_do_work+0x10/0x10 [cfg80211]  ? __kasan_check_read+0x11/0x1f  ? psi_group_change+0x8bc/0x944  ? __kasan_check_write+0x14/0x22  ? mutex_lock+0x8e/0xdc  ? __pfx_mutex_lock+0x10/0x10  ? __pfx___radix_tree_lookup+0x10/0x10  cfg80211_conn_work+0x245/0x34d [cfg80211]  ? __pfx_cfg80211_conn_work+0x10/0x10 [cfg80211]  ? update_cfs_rq_load_avg+0x3bc/0x3d7  ? sched_clock_noinstr+0x9/0x1a  ? sched_clock+0x10/0x24  ? sched_clock_cpu+0x7e/0x42e  ? newidle_balance+0x796/0x937  ? __pfx_sched_clock_cpu+0x10/0x10  ? __pfx_newidle_balance+0x10/0x10  ? __kasan_check_read+0x11/0x1f  ? psi_group_change+0x8bc/0x944  ? _raw_spin_unlock+0xe/0x24  ? raw_spin_rq_unlock+0x47/0x54  ? raw_spin_rq_unlock_irq+0x9/0x1f  ? finish_task_switch.isra.0+0x347/0x586  ? __schedule+0x27bf/0x2892  ? mutex_unlock+0x80/0xd0  ? do_raw_spin_lock+0x75/0xdb  ? __pfx___schedule+0x10/0x10  process_scheduled_works+0x58c/0x821  worker_thread+0x4c7/0x586  ? __kasan_check_read+0x11/0x1f  kthread+0x285/0x294  ? __pfx_worker_thread+0x10/0x10  ? __pfx_kthread+0x10/0x10  ret_from_fork+0x29/0x6f  ? __pfx_kthread+0x10/0x10  ret_from_fork_asm+0x1b/0x30  </TASK> | [1]https://git.kernel.org/stable/c/2403cb3c235d5e339b580cc3a825493769fadca8<br>[2]https://git.kernel.org/stable/c/5afcd6fcd1e1c1fd6bcc9a360c121d10eddade67<br>[3]https://git.kernel.org/stable/c/ba4bb0402c60e945c4c396c51f0acac3c3e3ea5c |
| 9 | CVE-2025-21731 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：nbd：断开连接后不允许重新连接<br><br>以下过程可能导致nbd_config使用后释放（UAF）：<br>1) 暂时获取nbd_config；<br>2) nbd_genl_disconnect()刷新所有recv_work()并释放初始引用：<br>   nbd_genl_disconnect<br>   nbd_disconnect_and_put<br>   nbd_disconnect<br>   flush_workqueue(nbd->recv_workq)<br>   如果 (test_and_clear_bit(NBD_RT_HAS_CONFIG_REF, ...))<br>      nbd_config_put<br>      -> 由于步骤1)，引用计数不为零<br>3) nbd_genl_reconfigure()再次排队recv_work()：<br>   nbd_genl_reconfigure<br>   config = nbd_get_config_unlocked(nbd)<br>   如果 (!config)<br>      -> 成功<br>   如果 (!test_bit(NBD_RT_BOUND, ...))<br>      -> 成功<br>   nbd_reconnect_socket<br>      queue_work(nbd->recv_workq, &args->work)<br>4) 步骤1)释放引用；<br>5) 最终，recv_work()将触发UAF：<br>   recv_work<br>   nbd_config_put(nbd)<br>      -> nbd_config被释放<br>   atomic_dec(&config->recv_threads)<br>      -> UAF<br><br>通过在nbd_genl_disconnect()中清除NBD_RT_BOUND来修复此问题，从而使nbd_genl_reconfigure()失败。 | [1]https://git.kernel.org/stable/c/844b8cdc681612ff24df62cdefddeab5772fadf1<br>[2]https://git.kernel.org/stable/c/9793bd5ae4bdbdb2dde401a3cab94a6bfd05e302<br>[3]https://git.kernel.org/stable/c/a8ee6ecde2b7bfb58c8a3afe8a9d2b848f580739<br>[4]https://git.kernel.org/stable/c/d208d2c52b652913b5eefc8ca434b0d6b757f68f<br>[5]https://git.kernel.org/stable/c/e7343fa33751cb07c1c56b666bf37cfca357130e |
| 10 | CVE-2024-49570 | 7.8  | HIGH | 在Linux内核中，已解决了以下漏洞：drm/xe/tracing：修复潜在的TP_printk使用后释放漏洞（UAF）提交afd2627f727b（"tracing：通过字段而非TP_printk格式检查"%s"的解引用"）揭示了xe_bo_move跟踪事件中的潜在UAF。通过避免在TP_printk时解引用xe_mem_type_to_name[]数组来修复这些漏洞。由于进行了一些代码重构，对于早于6.10版本的内核可能需要显式回退。 | [1]https://git.kernel.org/stable/c/07089083a526ea19daa72a1edf9d6e209615b77c<br>[2]https://git.kernel.org/stable/c/62cd174616ae3bf8a6cf468718f1ae74e5a07727<br>[3]https://git.kernel.org/stable/c/c9402da34611e1039ecccba3c1481c4866f7ca64 |
| 11 | CVE-2024-54458 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：scsi: ufs: bsg: 在移除后将bsg_queue设置为NULL。目前这不会引起任何问题，但我认为在移除后将bsg_queue设置为NULL是必要的，以防止潜在的使用后释放（UAF）访问。 | [1]https://git.kernel.org/stable/c/1e95c798d8a7f70965f0f88d4657b682ff0ec75f<br>[2]https://git.kernel.org/stable/c/5e7b6e44468c3242c21c2a8656d009fb3eb50a73<br>[3]https://git.kernel.org/stable/c/5f782d4741bf558def60df192b858b0efc6a5f0a<br>[4]https://git.kernel.org/stable/c/88a01e9c9ad40c075756ba93b47984461d4ff15d<br>[5]https://git.kernel.org/stable/c/9193bdc170cc23fe98aca71d1a63c0bf6e1e853b |
| 12 | CVE-2025-21739 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：scsi: ufs: core: 在初始化错误后修复了使用后的释放问题并移除了路径。`devm_blk_crypto_profile_init()` 注册了一个清理处理程序，在关联的（平台）设备被释放时运行。对于UFS，加密私有数据和指针作为 `ufs_hba` 数据结构 `struct ufs_hba::crypto_profile` 的一部分进行存储。此结构是在底层 `ufshcd` 和因此 `Scsi_host` 分配期间分配的。<br><br>在驱动程序释放或在 `ufshcd_pltfrm_init()` 的错误处理过程中，此结构会在与上述加密调用相关的（平台）设备被释放之前通过 `ufshcd_dealloc_host()` 进行释放。一旦该设备被释放，加密清理代码将在刚刚释放的 `struct ufs_hba::crypto_profile` 上运行，从而导致使用后的释放情况：<br><br>调用跟踪：<br><br>kfree+0x60/0x2d8 (P)<br>kvfree+0x44/0x60<br>blk_crypto_profile_destroy_callback+0x28/0x70<br>devm_action_release+0x1c/0x30<br>release_nodes+0x6c/0x108<br>devres_release_all+0x98/0x100<br>device_unbind_cleanup+0x20/0x70<br>really_probe+0x218/0x2d0<br><br><br>换句话说，初始化代码流程如下：<br>- 平台设备探测<br>  - `ufshcd_pltfrm_init()`<br>    - `ufshcd_alloc_host()`<br>      - `scsi_host_alloc()`<br>        - `struct ufs_hba` 的分配<br>        - `scsi-host` 设备的创建<br>    - `devm_blk_crypto_profile_init()`<br>      - 使用平台设备注册清理处理程序<br>- 在 `ufshcd_pltfrm_init()` 的错误处理或驱动程序移除期间：<br>  - `ufshcd_dealloc_host()`<br>    - `scsi_host_put()`<br>      - `put_device(scsi-host)`<br>        - `struct ufs_hba` 的释放<br>  - `put_device(platform-device)`<br>    - 加密清理处理程序<br><br>为了修复此使用后的释放问题，将 `ufshcd_alloc_host()` 更改为注册一个 `devres` 动作，以便在 `ufshcd` 销毁时自动清理底层的SCSI设备，而不需要显式调用 `ufshcd_dealloc_host()`。这样可以实现以下效果：<br>- 在SCSI之前销毁加密配置文件和其他所有由 `ufs_hba` 拥有的资源（因为它们已在之后注册）<br>- 作为副作用，在 `tc-dwc-g210-pci.c` 的 `remove()` 中修复了一个内存泄漏<br>- 可以完全删除 `EXPORT_SYMBOL_GPL(ufshcd_dealloc_host)`，因为它不再需要<br>- 未来使用 `ufshcd_alloc_host()` 的任何驱动程序都不会忘记添加清理 | [1]https://git.kernel.org/stable/c/0c77c0d754fe83cb154715fcfec6c3faef94f207<br>[2]https://git.kernel.org/stable/c/9c185beae09a3eb85f54777edafa227f7e03075d<br>[3]https://git.kernel.org/stable/c/f8fb2403ddebb5eea0033d90d9daae4c88749ada |
| 13 | CVE-2025-21751 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：net/mlx5: HWS，在匹配器断开连接时更改错误流程当前，当在匹配器断开连接流程中发生固件故障时，函数的错误流程会重新连接匹配器并返回一个错误，这会导致调用函数继续运行，并最终释放正在断开连接的匹配器。这导致了一个情况，即我们有一个已释放的匹配器在匹配器列表中，进而导致使用后释放和最终崩溃。此补丁通过在断开连接期间某些固件命令失败时不尝试重新连接匹配器来修复该问题。请注意，我们在这里处理的是固件错误。我们无法克服这个问题。这可能导致不良的分流状态（例如，匹配器之间的错误连接），并且还会导致资源泄漏，因为这是在资源销毁期间任何其他错误处理的情况。然而，这里的目的是让驱动程序继续运行，而不是因使用后释放而导致机器崩溃。 | [1]https://git.kernel.org/stable/c/1ce840c7a659aa53a31ef49f0271b4fd0dc10296<br>[2]https://git.kernel.org/stable/c/23a86c76a1a197e8fbbbd0ce3e826eb58c471624 |
| 14 | CVE-2025-21753 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：btrfs：修复在尝试加入已中止的事务时的使用后释放漏洞。当我们试图加入当前事务且该事务已中止时，在解锁fs_info->trans_lock后读取其`aborted`字段，并且没有对该事务进行额外的引用计数。这意味着一个并发任务可能在我们读取其`aborted`字段之前就中止并释放了该事务，从而导致使用后释放。通过在持有fs_info->trans_lock的情况下读取`aborted`字段来修复此问题，因为任何释放任务都必须首先获取该锁并将fs_info->running_transaction设置为NULL后再释放事务。该漏洞由syzbot和Dmitry报告，并附有以下来自KASAN的调用堆栈跟踪信息：<br><br>==================================================================  <br>BUG: KASAN: slab-use-after-free in join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278  <br>在地址ffff888011839024处大小为4字节的读取由任务kworker/u4:9/1128执行  <br>CPU: 0 UID: 0 PID: 1128 Comm: kworker/u4:9 不受保护的版本 6.13.0-rc7-syzkaller-00019-gc45323b7560e #0  <br>硬件名称：QEMU标准PC（Q35 + ICH9，2009），BIOS 1.16.3-debian-1.16.3-2~bpo12+1 04/01/2014  <br>工作队列：events_unbound btrfs_async_reclaim_data_space  <br>调用跟踪：  <br><TASK>  <br><inline>__dump_stack lib/dump_stack.c:94  <br><inline>dump_stack_lvl+0x241/0x360 lib/dump_stack.c:120  <br><inline>print_address_description mm/kasan/report.c:378  <br><inline>print_report+0x169/0x550 mm/kasan/report.c:489  <br><inline>kasan_report+0x143/0x180 mm/kasan/report.c:602  <br>join_transaction+0xd9b/0xda0 fs/btrfs/transaction.c:278  <br>start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697  <br>flush_space+0x448/0xcf0 fs/btrfs/space-info.c:803  <br>btrfs_async_reclaim_data_space+0x159/0x510 fs/btrfs/space-info.c:1321  <br><inline>process_one_work kernel/workqueue.c:3236  <br><inline>process_scheduled_works+0xa66/0x1840 kernel/workqueue.c:3317  <br>worker_thread+0x870/0xd30 kernel/workqueue.c:3398  <br>kthread+0x2f0/0x390 kernel/kthread.c:389  <br>ret_from_fork+0x4b/0x80 arch/x86/kernel/process.c:147  <br>ret_from_fork_asm+0x1a/0x30 arch/x86/entry/entry_64.S:244  <br></TASK>  <br>由任务5315分配：  <br><inline>kasan_save_stack mm/kasan/common.c:47  <br><inline>kasan_save_track+0x3f/0x80 mm/kasan/common.c:68  <br><inline>poison_kmalloc_redzone mm/kasan/common.c:377  <br><inline>__kasan_kmalloc+0x98/0xb0 mm/kasan/common.c:394  <br><inline>kasan_kmalloc include/linux/kasan.h:260  <br><inline>__kmalloc_cache_noprof+0x243/0x390 mm/slub.c:4329  <br><inline>kmalloc_noprof include/linux/slab.h:901  <br>join_transaction+0x144/0xda0 fs/btrfs/transaction.c:308  <br>start_transaction+0xaf8/0x1670 fs/btrfs/transaction.c:697  <br>btrfs_create_common+0x1b2/0x2e0 fs/btrfs/inode.c:6572  <br><inline>lookup_open fs/namei.c:3649  <br><inline>open_last_lookups fs/namei.c:3748  <br>path_openat+0x1c03/0x3590 fs/namei.c:3984  <br>do_filp_open+0x27f/0x4e0 fs/namei.c:4014  <br>do_sys_openat2+0x13e/0x1d0 fs/open.c:1402  <br>do_sys_open fs/open.c:1417  <br><inline>__do_sys_creat fs/open.c:1495  <br><inline>__se_sys_creat fs/open.c:1489  <br><inline>__x64_sys_creat+0x123/0x170 fs/open.c:1489  <br>do_syscall_x64 arch/x86/entry/common.c:52  <br>do_syscall_64+0xf3/0x230 arch/x86/entry/common.c:83  <br>entry_SYSCALL_64_after_hwframe+0x77/0x7f  <br>由任务5336释放：  <br><inline>kasan_save_stack mm/kasan/common.c:47  <br><inline>kasan_save_track+0x3f/0x80 mm/kasan/common.c:68  <br><inline>kasan_save_free_info+0x40/0x50 mm/kasan/generic.c:582  <br><inline>poison_slab_object mm/kasan/common.c:247  <br><inline>__kasan_slab_free+0x59/0x70 mm/kasan/common.c:264  <br><inline>kasan_slab_free include/linux/kasan.h:233  <br><inline>slab_free_hook mm/slub.c:2353  <br><inline>slab_free mm/slub.c:4613  <br>kfree+0x196/0x430 mm/slub.c:4761  <br>cleanup_transaction fs/btrfs/transaction.c:2063  <br>btrfs_commit_transaction+0x2c97/0x3720 fs/btrfs/transaction.c:2598  <br>insert_balance_item+0x1284/0x20b0 fs/btrfs/volumes.c:3757  <br>btrfs_balance+0x992/---truncated--- | [1]https://git.kernel.org/stable/c/6ba4663ada6c6315af23a6669d386146634808ec<br>[2]https://git.kernel.org/stable/c/86d71a026a7f63da905db9add845c8ee88801eca<br>[3]https://git.kernel.org/stable/c/8f5cff471039caa2b088060c074c2bf2081bcb01<br>[4]https://git.kernel.org/stable/c/ce628048390dad80320d5a1f74de6ca1e1be91e7<br>[5]https://git.kernel.org/stable/c/e2f0943cf37305dbdeaf9846e3c941451bcdef63 |
| 15 | CVE-2025-21756 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：vsock：保持绑定直到套接字销毁。保留套接字绑定；这包括由显式的bind()引起的绑定以及通过连接期间的自动绑定隐式绑定的那些。防止在传输重新分配过程中解除套接字绑定，这修复了使用后释放漏洞：<br>1. vsock_create()（引用计数=1）调用vsock_insert_unbound()（引用计数=2）<br>2. transport->release()调用vsock_remove_bound()而不检查sk是否已绑定并移动到绑定列表（引用计数=1）<br>3. vsock_bind()假设sk在未绑定列表中，并在调用__vsock_insert_bound(vsock_bound_sockets())之前调用__vsock_remove_bound()，该函数执行：<br>   list_del_init(&vsk->bound_table); // 无操作<br>   sock_put(&vsk->sk); // 引用计数=0<br><br>BUG: KASAN: slab-use-after-free 在 __vsock_bind+0x62e/0x730 中读取大小为4的地址 ffff88816b46a74c，任务 a.out/2057 dump_stack_lvl+0x68/0x90 print_report+0x174/0x4f6 kasan_report+0xb9/0x190 __vsock_bind+0x62e/0x730 vsock_bind+0x97/0xe0 __sys_bind+0x154/0x1f0 __x64_sys_bind+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e<br><br>由任务2057分配：<br>kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 __kasan_slab_alloc+0x85/0x90 kmem_cache_alloc_noprof+0x131/0x450 sk_prot_alloc+0x5b/0x220 sk_alloc+0x2c/0x870 __vsock_create.constprop.0+0x2e/0xb60 vsock_create+0xe4/0x420 __sock_create+0x241/0x650 __sys_socket+0xf2/0x1a0 __x64_sys_socket+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e<br><br>由任务2057释放：<br>kasan_save_stack+0x1e/0x40 kasan_save_track+0x10/0x30 kasan_save_free_info+0x37/0x60 __kasan_slab_free+0x4b/0x70 kmem_cache_free+0x1a1/0x590 __sk_destruct+0x388/0x5a0 __vsock_bind+0x5e1/0x730 vsock_bind+0x97/0xe0 __sys_bind+0x154/0x1f0 __x64_sys_bind+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e<br><br>引用计数：在0上增加；使用后释放。<br>警告：CPU: 7 PID: 2057 在lib/refcount.c:25 refcount_warn_saturate+0xce/0x150中<br>RIP: 0010:refcount_warn_saturate+0xce/0x150 __vsock_bind+0x66d/0x730 vsock_bind+0x97/0xe0 __sys_bind+0x154/0x1f0 __x64_sys_bind+0x6e/0xb0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e<br><br>引用计数：下溢；使用后释放。<br>警告：CPU: 7 PID: 2057 在lib/refcount.c:28 refcount_warn_saturate+0xee/0x150中<br>RIP: 0010:refcount_warn_saturate+0xee/0x150 vsock_remove_bound+0x187/0x1e0 __vsock_release+0x383/0x4a0 vsock_release+0x90/0x120 __sock_release+0xa3/0x250 sock_close+0x14/0x20 __fput+0x359/0xa80 task_work_run+0x107/0x1d0 do_exit+0x847/0x2560 do_group_exit+0xb8/0x250 __x64_sys_exit_group+0x3a/0x50 x64_sys_call+0xfec/0x14f0 do_syscall_64+0x93/0x1b0 entry_SYSCALL_64_after_hwframe+0x76/0x7e | [1]https://git.kernel.org/stable/c/3f43540166128951cc1be7ab1ce6b7f05c670d8b<br>[2]https://git.kernel.org/stable/c/645ce25aa0e67895b11d89f27bb86c9d444c40f8<br>[3]https://git.kernel.org/stable/c/b1afd40321f1c243cffbcf40ea7ca41aca87fa5e<br>[4]https://git.kernel.org/stable/c/fcdd2242c0231032fc84e1404315c245ae56322a |
| 16 | CVE-2025-21759 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：ipv6: mcast: 在igmp6_send()中扩展RCU保护igmp6_send()可以在未持有RTNL或RCU的情况下被调用。扩展RCU保护，以便我们可以安全地获取net指针并避免潜在的使用后释放（UAF）。请注意，我们现在不能再使用sock_alloc_send_skb()，因为ipv6.igmp_sk使用了可能会导致休眠的GFP_KERNEL分配。而是使用alloc_skb()并在RCU保护下为net->ipv6.igmp_sk套接字计费。 | [1]https://git.kernel.org/stable/c/087c1faa594fa07a66933d750c0b2610aa1a2946<br>[2]https://git.kernel.org/stable/c/0bf8e2f3768629d437a32cb824149e6e98254381<br>[3]https://git.kernel.org/stable/c/81b25a07ebf53f9ef4ca8f3d96a8ddb94561dd5a<br>[4]https://git.kernel.org/stable/c/8e92d6a413feaf968a33f0b439ecf27404407458 |
| 17 | CVE-2025-21760 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：ndisc：在ndisc_send_skb()中扩展RCU保护ndisc_send_skb()可以在没有持有RTNL或RCU的情况下被调用。提前获取rcu_read_lock()，以便可以使用dev_net_rcu()并避免潜在的使用后释放(UAF)漏洞。 | [1]https://git.kernel.org/stable/c/04e05112f10354ffc3bb6cc796d553bab161594c<br>[2]https://git.kernel.org/stable/c/789230e5a8c1097301afc802e242c79bc8835c67<br>[3]https://git.kernel.org/stable/c/a9319d800b5701e7f5e3fa71a5b7c4831fc20d6d<br>[4]https://git.kernel.org/stable/c/ae38982f521621c216fc2f5182cd091f4734641d<br>[5]https://git.kernel.org/stable/c/ed6ae1f325d3c43966ec1b62ac1459e2b8e45640 |
| 18 | CVE-2025-21761 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：openvswitch：在ovs_vport_cmd_fill_info()中使用RCU保护ovs_vport_cmd_fill_info()可以在没有RTNL或RCU的情况下被调用。使用RCU保护和dev_net_rcu()以避免潜在的使用后释放(UAF)漏洞。 | [1]https://git.kernel.org/stable/c/5828937742af74666192835d657095d95c53dbd0<br>[2]https://git.kernel.org/stable/c/7e01abc34e87abd091e619161a20f54ed4e3e2da<br>[3]https://git.kernel.org/stable/c/8ec57509c36c8b9a23e50b7858dda0c520a2d074<br>[4]https://git.kernel.org/stable/c/90b2f49a502fa71090d9f4fe29a2f51fe5dff76d<br>[5]https://git.kernel.org/stable/c/a849a10de5e04d798f7f286a2f1ca174719a617a |
| 19 | CVE-2025-21762 | 7.8  | HIGH | 在Linux内核中，以下漏洞已得到修复：arp：在arp_xmit()中使用RCU保护arp_xmit()可以在没有RTNL或RCU保护的情况下被调用。使用RCU保护以避免潜在的使用后释放(UAF)漏洞。 | [1]https://git.kernel.org/stable/c/01d1b5c9abcaff29a43f1d17a19c33eec92c7dbe<br>[2]https://git.kernel.org/stable/c/2c331718d3389b6c5f6855078ab7171849e016bd<br>[3]https://git.kernel.org/stable/c/a42b69f692165ec39db42d595f4f65a4c8f42e44<br>[4]https://git.kernel.org/stable/c/e9f4dee534eb1b225b0a120395ad9bc2afe164d3<br>[5]https://git.kernel.org/stable/c/f189654459423d4d48bef2d120b4bfba559e6039 |
| 20 | CVE-2025-21763 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：neighbour: 在__neigh_notify()中使用RCU保护__neigh_notify()可以在没有RTNL或RCU保护的情况下被调用。使用RCU保护以避免潜在的使用后释放(UAF)漏洞。 | [1]https://git.kernel.org/stable/c/1cbb2aa90cd3fba15ad7efb5cdda28f3d1082379<br>[2]https://git.kernel.org/stable/c/559307d25235e24b5424778c7332451b6c741159<br>[3]https://git.kernel.org/stable/c/784eb2376270e086f7db136d154b8404edacf97b<br>[4]https://git.kernel.org/stable/c/becbd5850c03ed33b232083dd66c6e38c0c0e569<br>[5]https://git.kernel.org/stable/c/cdd5c2a12ddad8a77ce1838ff9f29aa587de82df |
| 21 | CVE-2025-21764 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：ndisc：在ndisc_alloc_skb()中使用RCU保护ndisc_alloc_skb()可以在未持有RTNL或RCU的情况下被调用。添加RCU保护以避免可能的使用后释放(UAF)漏洞。 | [1]https://git.kernel.org/stable/c/3c2d705f5adf5d860aaef90cb4211c0fde2ba66d<br>[2]https://git.kernel.org/stable/c/628e6d18930bbd21f2d4562228afe27694f66da9<br>[3]https://git.kernel.org/stable/c/9e0ec817eb41a55327a46cd3ce331a9868d60304<br>[4]https://git.kernel.org/stable/c/bbec88e4108e8d6fb468d3817fa652140a44ff28<br>[5]https://git.kernel.org/stable/c/cd1065f92eb7ff21b9ba5308a86f33d1670bf926 |
| 22 | CVE-2025-21786 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：workqueue：在从池中分离救援程序后放置pwq。提交68f83057b913（“workqueue：通过kthread_stop()重新捕获工作程序并删除detach_completion”）添加了重新捕获普通工作程序的代码，但错误地未处理救援程序，并且还去除了在put_unbound_pool()中等待救援程序的代码，这导致Cheung Wall报告了一个使用后释放漏洞。<br><br>为了避免使用后释放漏洞，必须在分离完成之前持有池的引用。因此，将把pwq的代码移动到从池中分离救援程序之后。 | [1]https://git.kernel.org/stable/c/835b69c868f53f959d4986bbecd561ba6f38e492<br>[2]https://git.kernel.org/stable/c/e76946110137703c16423baf6ee177b751a34b7e<br>[3]https://git.kernel.org/stable/c/e7c16028a424dd35be1064a68fa318be4359310f |
| 23 | CVE-2025-21791 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：vrf: 在l3mdev_l3_out()中使用RCU保护l3mdev_l3_out()可以在没有持有RCU的情况下被调用：raw_sendmsg() ip_push_pending_frames() ip_send_skb() ip_local_out() __ip_local_out() l3mdev_ip_out()添加rcu_read_lock()/rcu_read_unlock()对以避免潜在的使用后释放(UAF)漏洞。 | [1]https://git.kernel.org/stable/c/022cac1c693add610ae76ede03adf4d9d5a2cf21<br>[2]https://git.kernel.org/stable/c/6d0ce46a93135d96b7fa075a94a88fe0da8e8773<br>[3]https://git.kernel.org/stable/c/7b81425b517accefd46bee854d94954f5c57e019<br>[4]https://git.kernel.org/stable/c/c40cb5c03e37552d6eff963187109e2c3f78ef6f<br>[5]https://git.kernel.org/stable/c/c7574740be8ce68a57d0aece24987b9be2114c3c |
| 24 | CVE-2025-21796 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：nfsd：在释放acl_access/acl_default后清除它们。如果获取acl_default失败，acl_access和acl_default将同时被释放。然而，acl_access仍将保留一个指向已释放的posix_acl的指针，这将在类似nfs3svc_release_getacl中触发警告：<br><br><br>------------[ 切换到这里 ]------------<br>refcount_t: 溢出；使用后释放。<br>WARNING: CPU: 26 PID: 3199 在 lib/refcount.c:28<br>refcount_warn_saturate+0xb5/0x170<br>模块链接：<br>CPU: 26 UID: 0 PID: 3199 进程: nfsd 不是最新版本6.12.0-rc6-00079-g04ae226af01f-dirty #8<br>硬件名称: QEMU Standard PC (i440FX + PIIX, 1996)，BIOS 1.16.1-2.fc37 04/01/2014<br>RIP: 0010:refcount_warn_saturate+0xb5/0x170<br>代码: cc cc 0f b6 1d b3 20 a5 03 80 fb 01 0f 87 65 48 d8 00 83 e3 01 75 e4 48 c7 c7 c0 3b 9b 85 c6 05 97 20 a5 03 01 e8 fb 3e 30 ff <0f> 0b eb cd 0f b6 1d 8a 3<br>RSP: 0018:ffffc90008637cd8 EFLAGS: 00010282<br>RAX: 0000000000000000 RBX: 0000000000000000 RCX: ffffffff83904fde<br>RDX: dffffc0000000000 RSI: 0000000000000008 RDI: ffff88871ed36380<br>RBP: ffff888158beeb40 R08: 0000000000000001 R09: fffff520010c6f56<br>R10: ffffc90008637ab7 R11: 0000000000000001 R12: 0000000000000001<br>R13: ffff888140e77400 R14: ffff888140e77408 R15: ffffffff858b42c0<br>FS:  0000000000000000(0000) GS:ffff88871ed00000(0000)knlGS:0000000000000000<br>CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033<br>CR2: 0000562384d32158 CR3: 000000055cc6a000 CR4: 00000000000006f0<br>DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000<br>DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400<br><br>调用跟踪:<br><TASK> ? refcount_warn_saturate+0xb5/0x170<br>? __warn+0xa5/0x140<br>? refcount_warn_saturate+0xb5/0x170<br>? report_bug+0x1b1/0x1e0<br>? handle_bug+0x53/0xa0<br>? exc_invalid_op+0x17/0x40<br>? asm_exc_invalid_op+0x1a/0x20<br>? tick_nohz_tick_stopped+0x1e/0x40<br>? refcount_warn_saturate+0xb5/0x170<br>? refcount_warn_saturate+0xb5/0x170<br>nfs3svc_release_getacl+0xc9/0xe0<br>svc_process_common+0x5db/0xb60<br>? __pfx_svc_process_common+0x10/0x10<br>? __rcu_read_unlock+0x69/0xa0<br>? __pfx_nfsd_dispatch+0x10/0x10<br>? svc_xprt_received+0xa1/0x120<br>? xdr_init_decode+0x11d/0x190<br>svc_process+0x2a7/0x330<br>svc_handle_xprt+0x69d/0x940<br>svc_recv+0x180/0x2d0<br>nfsd+0x168/0x200<br>? __pfx_nfsd+0x10/0x10<br>kthread+0x1a2/0x1e0<br>? kthread+0xf4/0x1e0<br>? __pfx_kthread+0x10/0x10<br>ret_from_fork+0x34/0x60<br>? __pfx_kthread+0x10/0x10<br>ret_from_fork_asm+0x1a/0x30<br></TASK><br><br>内核恐慌 - 不同步：内核: panic_on_warn 已设置...<br><br>在调用posix_acl_release之后清除acl_access/acl_default以防止UAF被触发。 | [1]https://git.kernel.org/stable/c/1fd94884174bd20beb1773990fd3b1aa877688d9<br>[2]https://git.kernel.org/stable/c/2e59b2b68782519560b3d6a41dd66a3d01a01cd3<br>[3]https://git.kernel.org/stable/c/55d947315fb5f67a35e4e1d3e01bb886b9c6decf<br>[4]https://git.kernel.org/stable/c/7faf14a7b0366f153284db0ad3347c457ea70136<br>[5]https://git.kernel.org/stable/c/f8d871523142f7895f250a856f8c4a4181614510 |
| 25 | CVE-2025-21797 | 7.8  | HIGH | 在Linux内核中，已解决以下漏洞：HID: corsair-void: 为耳机状态添加缺失的延迟工作取消。在corsair_void_remove()中漏掉了cancel_delayed_work_sync()调用，导致使用后释放。 | [1]https://git.kernel.org/stable/c/2dcb56a0a4da6946f6c18288da595c13e0d2af86<br>[2]https://git.kernel.org/stable/c/48e487b002891eb0aeaec704c9bed51f028deff1 |
| 26 | CVE-2024-2297 | 7.1  | HIGH | Bricks 主题对于 WordPress 存在权限提升漏洞，影响所有版本直至包括 1.9.6.1。这是由于对 create_autosave AJAX 函数的验证检查不足。这使得经过身份验证的攻击者（具有贡献者级别及以上访问权限）能够在拥有提升的（管理员级别）权限下执行任意 PHP 代码。注意：成功的利用需要满足以下条件：(1) 在文章中启用 Bricks 构建器；(2) 为贡献者级别的用户启用构建器访问权限；(3) 在主题设置中为管理员级别用户启用“代码执行”。 | [1]https://bricksbuilder.io/release/bricks-1-9-7/<br>[2]https://www.wordfence.com/threat-intel/vulnerabilities/id/cb075e85-75fc-4008-8270-4d1064ace29e?source=cve |
| 27 | CVE-2025-1295 | 8.8  | HIGH | Templines Elementor Helper Core插件对于WordPress而言，在所有版本包括2.7版本都存在权限提升漏洞。这是由于允许任意用户元更新所导致的。这使得认证攻击者，具有订户及以上级别的访问权限，能够将其角色更新为管理员。此漏洞仅在同时安装并激活BuddyPress插件时可以被利用。 | [1]http://localhost:1337/wp-content/plugins/templines-helper-core/youzify/youzify.php#L3082<br>[2]https://www.wordfence.com/threat-intel/vulnerabilities/id/8c5aa062-b9a2-4ddb-a5bf-4c8368218e85?source=cve |
| 28 | CVE-2025-1717 | 8.1  | HIGH | 《WordPress》的《Login Me Now》插件在1.7.2及以下版本中存在身份验证绕过漏洞。这是由于`AutoLogin::listen()`函数中基于任意瞬态名称的不安全身份验证造成的。这使得未认证的攻击者能够登录网站上的现有用户，甚至是管理员。注意：此漏洞需要使用来自其他软件的瞬态名称和值，因此该插件本身并不是固有易受攻击的。 | [1]https://plugins.trac.wordpress.org/browser/login-me-now/tags/1.7.2/app/Logins/BrowserTokenLogin/AutoLogin.php#L24<br>[2]https://www.wordfence.com/threat-intel/vulnerabilities/id/fc689622-50d6-47c4-a5f6-0314b1a207c9?source=cve |
| 29 | CVE-2025-1282 | 8.8  | HIGH | 汽车经销商WordPress主题——适用于WordPress的响应式主题，在所有版本（包括1.6.3）中，由于在`delete_post_photo()`和`add_car()`函数中对文件路径验证不足，存在任意文件删除漏洞。这使得认证攻击者（具有订阅者及以上权限）能够在服务器上删除任意文件，当删除正确的文件（如wp-config.php）时，这很容易导致远程代码执行。`add_car()`函数也可能使得读取任意文件成为可能。 | [1]https://themeforest.net/item/car-dealer-automotive-wordpress-theme-responsive/8574708?s_rank=7<br>[2]https://www.wordfence.com/threat-intel/vulnerabilities/id/edf4b588-8b67-425a-b0e1-d4382cb88dd1?source=cve |
| 30 | CVE-2025-1751 | 9.8  | CRITICAL | 在ATISoluciones的Ciges 2.15.5中发现了一个SQL注入漏洞。此漏洞允许攻击者通过/modules/ajaxBloqueaCita.php端点的$idServicio参数检索、创建、更新和删除数据库。 | [1]https://www.atisoluciones.com/incidentes-cve |
| 31 | CVE-2025-1691 | 7.6  | HIGH | MongoDB Shell 可能容易受到控制字符注入的影响。攻击者如果控制了 mongosh 自动补全功能，可以利用此功能输入并运行经过混淆的恶意文本。这需要用户交互，即用户使用 'tab' 键来自动补全以攻击者准备的自动补全内容为前缀的文本。该问题影响 mongosh 版本 2.3.9 之前的版本。此漏洞仅在 mongosh 连接到部分或完全受攻击者控制的集群时才可被利用。 | [1]https://jira.mongodb.org/browse/MONGOSH-2024 |
| 32 | CVE-2025-1739 | 7.1  | HIGH | 在TrivisionSecurity的Trivision Camera NC227WF v5.8.0中发现了一个认证绕过漏洞。此漏洞允许攻击者通过使用curl发送带有随机凭据的请求到"/en/player/activex_pal.asp"并成功对应用程序进行身份验证，从而以明文形式获取管理员凭证。 | [1]https://www.incibe.es/en/incibe-cert/notices/aviso/multiple-vulnerabilities-trivision-camera-nc227wf |
| 33 | CVE-2024-9334 | 8.2  | HIGH | 使用硬编码凭证和在无访问控制机制中存储敏感数据的漏洞允许绕过身份验证。此问题影响 E-Kent Pallium 车辆跟踪系统：版本早于 2024 年 10 月 17 日。 | [1]https://www.usom.gov.tr/bildirim/tr-25-0044 |
| 34 | CVE-2025-22280 | 7.6  | HIGH | revmakx DefendWP防火墙中的授权缺失漏洞允许利用访问控制安全级别配置不当的问题。此问题影响DefendWP防火墙：从n/a到1.1.0版本。 | [1]https://patchstack.com/database/wordpress/plugin/defend-wp-firewall/vulnerability/wordpress-defendwp-firewall-plugin-1-1-0-broken-access-control-vulnerability?_s_id=cve |
| 35 | CVE-2024-13148 | 9.8  | CRITICAL | Yukseloglu Filter B2B登录平台中存在不恰当的特殊元素过滤，导致在SQL命令中出现未被妥善处理的情况（即SQL注入漏洞）。此问题影响B2B登录平台版本：2025年1月16日之前的所有版本。 | [1]https://www.usom.gov.tr/bildirim/tr-25-0045 |
| 36 | CVE-2025-25761 | 7.2  | HIGH | HkCms v2.3.2.240702 被发现其组件 Appcenter.php 中存在任意文件写入漏洞。 | [1]https://github.com/147536951/Qianyi-learn/blob/main/Hkcms.pdf<br>[2]https://github.com/147536951/Qianyi-learn/blob/main/Hkcms.pdf |
| 37 | CVE-2025-1755 | 7.5  | HIGH | MongoDB Compass 在某些条件下可能容易受到本地权限提升的影响，当在 C:\node_modules\ 中存储了精心制作的文件时，可能会在用户的系统上以提升的权限执行未经授权的操作。此问题影响 MongoDB Compass 在 1.42.1 之前的版本。 | [1]https://jira.mongodb.org/browse/COMPASS-9058<br>[2]https://access.redhat.com/errata/RHSA-2025:1755.html |
| 38 | CVE-2025-1756 | 7.5  | HIGH | mongosh 在某些条件下可能容易受到本地权限提升的影响，这可能导致在用户的系统上以提升的权限执行未经授权的操作，当一个精心制作的文件存储在 C:\node_modules\ 中时。此问题影响 mongosh 2.3.0 之前的版本。 | [1]https://jira.mongodb.org/browse/MONGOSH-2028<br>[2]https://access.redhat.com/errata/RHSA-2025:1756 |
| 39 | CVE-2025-25333 | 7.5  | HIGH | IKEA中国iOS 4.13.0版本中存在的问题允许攻击者通过提供精心构造的链接来访问敏感的用户信息。 | [1]https://github.com/ZhouZiyi1/Vuls/blob/main/250116-IKEACN/250116-IKEACN.pdf |
| 40 | CVE-2025-23687 | 7.1  | HIGH | 在Web页面生成过程中对输入的不当 neutralization（跨站脚本攻击 `Cross-site Scripting`）漏洞存在于 simonhunter Woo Store Mode 中，允许反射型跨站脚本攻击。此问题影响 Woo Store Mode：从 n/a 至 1.0.1。 | [1]https://patchstack.com/database/wordpress/plugin/woo-store-mode/vulnerability/wordpress-woo-store-mode-plugin-1-0-1-reflected-cross-site-scripting-xss-vulnerability?_s_id=cve |